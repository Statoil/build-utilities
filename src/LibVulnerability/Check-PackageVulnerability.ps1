param(
    [string]$SolutionFolder
)

$ConfirmPreference = "None"

function AddPackage($packages, $name, $version, $project) {    
    $p = $packages[$name]

    if ($p -eq $null) {
        $packages[$name] = @{ Projects = @{ $project = $version } }
    }
    else {
        $p.Projects[$project] = $version
    }
}

function Load-PackagesCsproj([System.IO.FileInfo]$file, $packages) {
    Write-Host "Loading packages from $($file.FullName)"
    $pckCount = 0
    $xml = [xml](Get-Content $file.FullName)
    $references = $xml | Select-Xml -XPath "//PackageReference" | Select-Object -Expand Node
    foreach ($ref in $references) {
        $pckCount += 1        
        AddPackage $packages $ref.Include $ref.Version $file.Directory.Name
    }

    Write-Host "Found $pckCount packages"
}

function Load-PackagesJson([System.IO.FileInfo]$file, $packages) {
    Write-Host "Loading packages from $($file.FullName)" -ForegroundColor Yellow

    [psobject]$cfg = ConvertFrom-Json -InputObject ([string](Get-Content $file.FullName))
    $pckCount = 0
    foreach ($package in $cfg.dependencies.psobject.properties) {
        $pckCount += 1

        AddPackage $packages $package.Name $package.Value $file.Directory.Name
    }   
    Write-Host "Found $pckCount packages" -ForegroundColor Green
}

function Load-PackagesXml([System.IO.FileInfo]$file, $packages) {
    Write-Host "Loading packages from $($file.FullName)" -ForegroundColor Yellow

    [xml]$cfg = Get-Content $file.FullName
    
    $pckCount = 0
    $cfg.packages.package | ForEach-Object { $pckCount += 1; AddPackage $packages $_.id $_.version $file.Directory.Name }
    
    Write-Host "Found $pckCount packages" -ForegroundColor Green   
}

function Query-PackageVulnerability($packages, [string]$solution) {
    # Load cached items
    # $cache = Load-OSSIndexCache $solution
    $updateTime = Query-OSSIndexUpdateTime

    if ($cache -eq $null -or ($cache -ne $null -and (Is-CacheExpired $cache $packages $updateTime))) {
        $queryPayload = $solutionPackages.GetEnumerator() | ForEach-Object { @{ "pm" = "nuget"; "name" = $_.Name } }
        $queryResult = Invoke-RestMethod -Method Post -Uri "https://ossindex.net/v2.0/package" -Body (ConvertTo-Json -InputObject $queryPayload)
		
        #Save-OSSIndexCache -solutionDir $solution -updateTime $updateTime -ossResult $queryResult -solutionPackages $packages
		
        return $queryResult
    }
    else {
        return $cache.OSSResult.Value
    }
}

function Query-OSSIndexUpdateTime {
    $queryResult = Invoke-RestMethod -Method Get -Uri "https://ossindex.net/v2.0/pm/nuget/update" 
    $date = Get-DateFromUnixEpoch $queryResult
    Write-Host "Last OSSIndex update for nuget: ", $date
    return $queryResult
}

function AnalyseVulnerabilities($ossResult, $packages) {

    ReportUnkownPackages $ossResult

    # Analyse - general vulnerability
    [System.Array]$vulnerablePackages = $ossResult | where -Property "vulnerability-total" -gt 0
    
    if ($vulnerablePackages.Count -gt 0) {
        Write-Host "(w) Detected packages with vulnerabilities [$($vulnerablePackages.Count)]:" -ForegroundColor Cyan
        $vulnerablePackages | foreach { Write-Host $_.name -ForegroundColor Magenta -BackgroundColor Black }

        $vulnerablePackages | foreach { AnalysePackageVulnerability $_ $packages }
    }

}

function ReportUnkownPackages($ossResult) {

    # Analyse - Unkown packages
    [System.Array]$unkownPackages = $ossResult | where -Property id -eq 0
    if ($unkownPackages -ne $null) {
        Write-Host "Found $($unkownPackages.Count) unidentified packages" -ForegroundColor Cyan
        $unkownPackages | select -Property name
    }

}

function AnalysePackageVulnerability($ossPackageInfo, $packages) {
    [string]$packageName = $ossPackageInfo.name

    [System.Array]$installedVersions = $packages[$packageName].Projects.GetEnumerator() | select -Property Value -Unique -ExpandProperty Value
    
    # Check each vulnerability for match against installed version
    foreach ($vulnerability in $ossPackageInfo.vulnerabilities) {
        Write-Host "---------------------------------" -ForegroundColor Yellow -BackgroundColor Black
        Write-Host "Package: " -NoNewline; Write-Host "$packageName" -BackgroundColor Red -ForegroundColor White
        Write-Host "Checking potential vulnerability: " -NoNewline 
        Write-Host -ForegroundColor Magenta "$($vulnerability.title)"
        
        
        $detections = New-Object System.Collections.Generic.List[System.Object]

        $affectedVersion = @{}

        foreach ($vVersion in $vulnerability.versions) {
            foreach ($iVersion in $installedVersions) {
                if (IsVersionAffected $iVersion $vVersion) {
                    $detections.Add(@{
                            Package = $packageName
                            InstalledVersion = $iVersion
                            VulnerabilityVersion = $vVersion
                            Projects = $packages[$packageName].Projects
                        }
                    )
                }
            }
        }

        if ($detections.Count -eq 0) {
            Write-Host "Affected version(s):", ([System.String]::Join(", ", $vulnerability.versions))
            Write-Host "Installed version(s):", ([System.String]::Join(", ", $installedVersions))
            Write-Host "`t", "(ok) No installed versions affected" -ForegroundColor Green 
        }
        else {
            foreach ($detection in $detections) {
                Write-VulnerabilityInfo $vulnerability $detection   
                Write-Host ""
            }
        }
    }
    return $detections.Count
}

function Write-VulnerabilityInfo($vulnerability, $detection) {
    Write-Host "Found vulnerability in installed version " -NoNewline -ForegroundColor Red
    Write-Host "$($detection.InstalledVersion)" -ForegroundColor White -BackgroundColor Red -NoNewline
    Write-Host " using version identifier: " -NoNewline 
    Write-Host "$($detection.VulnerabilityVersion)" -ForegroundColor White -BackgroundColor Red
                    
    Write-Host "`n--------- INFO ---------"                    
    Write-Host $vulnerability.description
    Write-Host "`n# Library: $packageName"
    Write-Host "# Updated: ", (Get-DateFromUnixEpoch $vulnerability.updated)
    Write-Host "# References: "
    $vulnerability.references | foreach { Write-Host $_ }
                    
    Write-Host "`n--------- Affected Projects -----------"
    $detection.Projects.GetEnumerator() | foreach { Write-Host $_.Name, "[$($_.Value)]" }
}

function IsVersionAffected([string]$iVersion, [string]$vVersion) {
    $vVersionActual = $vVersion -replace "[<>=]"

    $versionComparison = Compare-PackageVersion $iVersion $vVersionActual

    if ($vVersion -match "[<>]") {
        # Is range
        if ($vVersion -match "[<>]=" -and $versionComparison -eq 0) {
            return $true
        }

        if ($vVersion -match "^<") {
            # Less than
            return $versionComparison -lt 0
        }
        elseif ($vVersion -match "^>") {
            # Not sure if this is a permitted version identifier but in any case..
            return $versionComparison -gt 0
        }

    }
    else {
        return $versionComparison -eq 0
    }
}

function Is-CacheExpired($ossCache, $packages, $updateTime) {
    Write-Host "(d) Checking cache expiration" -ForegroundColor DarkGray
    
    $isExpired = $false

    if ($updateTime > $cache.UpdateTime) {
        Write-Host "(i) OSSIndex has been updated since last check" -ForegroundColor Yellow
        $isExpired = $true
    }
    
    # Has packages updated
    foreach ($package in $packages.GetEnumerator()) {
        
        $cachePackage = $ossCache.SolutionPackages.psobject.Properties | where -Property Name -eq $package.Name | select -ExpandProperty Value

        if ($cachePackage -eq $null) {
            Write-Host "(i) Discovered new package:", $package.Name -ForegroundColor Yellow
            $isExpired = $true
        }

        # Check versioning --
        # Get unique list of installed version
        [System.Array]$installedVersions = $package.Value.Projects.GetEnumerator() | select -ExpandProperty Value -Unique 
        # Get list of cache versions
        [System.Array]$cacheVersions = $cachePackage.Projects.psobject.Properties | select -ExpandProperty Value -Unique

        if (@(Compare-Object $installedVersions $cacheVersions -IncludeEqual -ExcludeDifferent).Count -ne $installedVersions.Count) {
            Compare-Object $installedVersions $cacheVersions | foreach { Write-Host "(i) Found new installed version: $($_.InputObject)" -ForegroundColor Yellow }
            $isExpired = $true
        }
    }

    if ($isExpired -eq $false) {
        Write-Host "(d) Cache is not expired" -ForegroundColor DarkGreen
    }

    return $isExpired
}

function Compare-PackageVersion($v1, $v2) {
    $iVersionTokens = $v1.Split(".") # Split version
    $vVersionTokens = $v2.Split(".")

    $result = 0
    
    $maxCount = (@($iVersionTokens.Count, $vVersionTokens.Count) | measure -Maximum).Maximum

    for ($i = 0; $i -lt $maxCount; $i++) {
        if ($vVersionTokens.Count -lt $i + 1) {
            $result = Compare-VersionPart $iVersionTokens[$i] "0"
        }
        elseif ($iVersionTokens.Count -lt $i + 1) {
            $result = Compare-VersionPart "0" $vVersionTokens[$i]
        }
        else {
            $result = Compare-VersionPart $iVersionTokens[$i] $vVersionTokens[$i]
        }

        if ($result -ne 0) {
            return $result
        }
    }

    return $result
}

function Compare-VersionPart([string]$s1, [string]$s2) {    
    [int]$i1, [int]$i2 = 0, 0

    if ([int]::TryParse($s1, [ref]$i1) -and [int]::TryParse($s2, [ref]$i2)) {
        return $i1.CompareTo($i2)
    }
    return $s2.CompareTo($s2)
}

function Get-DateFromUnixEpoch([long]$milliseconds) {
    $d = New-Object System.DateTime -ArgumentList @(1970, 1, 1, 0, 0, 0, [System.DateTimeKind]::Utc)
    return $d.AddMilliseconds($milliseconds)
}




function Load-OSSIndexCache([string]$solutionDir) {
    $ossCacheFile = Get-OSSIndexCacheFile
    $cacheKey = Get-OSSIndexCacheKey $solutionDir   

    Write-Host "(d) Looking for cache with key:", $cacheKey -ForegroundColor DarkGray
    
    try {
        $ossCache = ConvertFrom-Json -InputObject ([string](Get-Content -Path $ossCacheFile))
        if ($ossCache -eq $null) {
            return $null
        }    
        
        $cache = ($ossCache.psobject.Properties | where -Property Name -eq $cacheKey).Value
        return $cache
    }
    catch {
        return $null
    }
}


function Save-OSSIndexCache([string]$solutionDir, [long]$updateTime, $ossResult, $solutionPackages) {
    $ossCacheFile = Get-OSSIndexCacheFile

    $ossCache = Get-Content -Path $ossCacheFile | ConvertFrom-Json
    $cacheKey = Get-OSSIndexCacheKey $solutionDir
    $cacheValueObject = @{
        UpdateTime = $updateTime
        OSSResult = $ossResult
        SolutionPackages = $solutionPackages
    }

    Write-Host "(i) Updating cache for solution: $solutionDir [$cacheKey]" -ForegroundColor Yellow

    if ($ossCache -eq $null) {
        # new        
        $ossCache = @{
            $cacheKey = $cacheValueObject
        }
    }
    else {
        # Update
        Add-Member -InputObject $ossCache -MemberType NoteProperty -Name $cacheKey -Force -Value $cacheValueObject
    }

    ConvertTo-Json -InputObject $ossCache -Depth 10 | Out-File -FilePath $ossCacheFile
}


function Get-OSSIndexCacheFile {
    $ossCacheFile = Join-Path ([io.path]::GetTempPath()) "osscache.txt"

    if (!(Test-Path $ossCacheFile)) {
        Write-Host "Creating cache file @ $ossCachefile" -ForegroundColor Yellow
        New-Item $ossCacheFile -Force -Confirm:$true
    }
    return Join-Path ([io.path]::GetTempPath()) "osscache.txt"
}
function Get-OSSIndexCacheKey([string]$string) {
    $cacheKey = $string -replace ":" -replace "\\", "_"
    return $cacheKey
}


##
# RUN SCRIPT
##

[string]$solutionPath = $PWD
if ($SolutionFolder -ne $null) {
    $solutionPath = $SolutionFolder  
}

$solutionPackages = @{}

# Get project.json files
Get-ChildItem -Path $solutionPath -Include project.json -Recurse | ForEach-Object { Load-PackagesJson $_ $solutionPackages }
Get-ChildItem -Path $solutionPath -Include packages.config -Recurse | ForEach-Object { Load-PackagesXml $_ $solutionPackages }
Get-ChildItem -Path $solutionPath -Filter *.csproj -Recurse | ForEach-Object { Load-PackagesCsproj $_ $solutionPackages }

Write-Host "Found $($solutionPackages.Keys.Count) distinct packages" -ForegroundColor Green
Write-Host "Querying for vulnerability...." -ForegroundColor Yellow

if ($solutionPackages.Count -eq 0) {
    Write-Host "No packages to check" -ForegroundColor Green    
}
else {

    $ossResult = Query-PackageVulnerability $solutionPackages $solutionPath

    $detectedVulnerabilities = AnalyseVulnerabilities $ossResult $solutionPackages
}

return $detectedVulnerabilities